// @flow
import type {
  RootNode,
  ASTNode,
  ASTNodes,
  DocumentNode,
} from "@orglnd/org-types";

export default function render(root: DocumentNode, options: {}): string {
  const document = [];
  traverse(document)(root);

  if (root.footnotes && Object.keys(root.footnotes)) {
    const footnotes = [];
    Object.keys(root.footnotes).forEach(id => {
      const node = root.footnotes[id];
      const innerText = [];
      node.children.forEach(child => {
        traverse(innerText)(child);
      });

      footnotes.push(
        `<div><sup><a id="fn.${id}" href="#fnrf.${id}">${id}</a></sup><span>${innerText.join(
          ``
        )}</span></div>`
      );
    });
    document.push(`<div id="text-footnotes">${footnotes.join(`\n`)}</div>`);
  }

  return document.join(`\n`);
}

function traverse(parent: Array<string>): ASTNode => void {
  return node => {
    let content;
    let nodesToWalk = [];
    let elementName = ``;
    let joinSeparator = ``;
    switch (node.type) {
      case `Document`:
        content = [];
        node.children.forEach(node => {
          traverse(content)(node);
        });
        parent.push(`<div class="content">${content.join(``)}</div>`);
        break;
      case `Headline`:
        nodesToWalk = node.title;
        elementName = `h${node.depth}`;
        break;
      case `Section`:
        nodesToWalk = node.children;
        elementName = `div`;
        break;
      case `Paragraph`:
        nodesToWalk = node.children;
        elementName = `p`;
        break;
      case `Table`:
        nodesToWalk = node.children;
        elementName = `table`;
        break;
      case `TableRow`:
        nodesToWalk = node.children;
        elementName = `tr`;
        joinSeparator = `\n`;
        break;
      case `TableCell`:
        nodesToWalk = node.children;
        elementName = `td`;
        joinSeparator = `\n`;
        break;
      case `List`:
        if (node.listType === `DescriptionList`) {
          content = [];
          node.children.forEach(node => {
            traverse(content)(node);
          });
          parent.push(`<dl>\n${content.join(`\n`)}</dl>`);
          break;
        }

        nodesToWalk = node.children;
        elementName = node.listType === `UnorderedList` ? `ul` : `ol`;
        joinSeparator = `\n`;
        break;
      case `ListItem`:
        if (node.listType === `DescriptionList`) {
          let termContent = [];
          node.term.forEach(node => {
            traverse(termContent)(node);
          });
          content = [];
          node.children.forEach(node => {
            traverse(content)(node);
          });
          parent.push(
            `<dt>\n${termContent.join(``)}</dt><dd>${content.join(``)}</dd>`
          );
          break;
        }
        nodesToWalk = node.children;
        elementName = `li`;
        joinSeparator = `\n`;
        break;
      case `Block`:
        switch (node.name) {
          case `QUOTE`:
            nodesToWalk = node.children;
            elementName = `blockquote`;
            joinSeparator = `\n`;
            break;
          case `SRC`:
            content = [];
            node.children.forEach(node => {
              traverse(content)(node);
            });
            parent.push(`<pre><code>\n${content.join(`\n`)}</code></pre>`);
            break;
          case `EXAMPLE`:
            content = [];
            node.children.forEach(node => {
              traverse(content)(node);
            });
            parent.push(
              `<pre class="example"><code>\n${content.join(`\n`)}</code></pre>`
            );
            break;
          case `EXPORT`:
            // org-export doesn't seem to handle this
            break;
          default:
            content = [];
            node.children.forEach(node => {
              traverse(content)(node);
            });
            parent.push(
              `<div class="${node.name}">\n${content.join(`\n`)}</div>`
            );
            break;
        }
        break;
      case `HorizontalRule`:
        parent.push(`<hr />`);
        break;
      case `Comment`:
        parent.push(`<!-- ${node.value} -->`);
        break;
      case `Link`:
        let linkText = node.link;
        if (node.children.length) {
          content = [];

          node.children.forEach(node => {
            traverse(content)(node);
          });

          linkText = content.join(``);
        }
        parent.push(`<a href="${node.link}">${linkText}</a>`);
        break;
      case `Bold`:
        nodesToWalk = node.children;
        elementName = `strong`;
        break;
      case `Italic`:
        nodesToWalk = node.children;
        elementName = `em`;
        break;
      case `Underline`:
        content = [];
        node.children.forEach(node => {
          traverse(content)(node);
        });
        parent.push(
          `<div style="text-decoration:underline">${content.join(``)}</div>`
        );
        break;
      case `Verbatim`:
      case `Code`:
        nodesToWalk = node.children;
        elementName = `code`;
        break;
      case `RawText`:
      case `Text`:
        parent.push(node.value);
        break;
    }

    if (nodesToWalk.length) {
      content = [];
      nodesToWalk.forEach(node => {
        traverse(content)(node);
      });
      parent.push(
        `<${elementName}>${content.join(joinSeparator)}</${elementName}>`
      );
    }
  };
}

function walk(node: ASTNode, cb: (node: ASTNode) => void) {
  cb(node);
  if (node.children && node.children.length) {
    node.children.forEach(child => {
      walk(child, cb);
    });
  }
}
